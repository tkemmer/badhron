// ====================================================================================================================
//  result
struct BadhronCheckResult {
	passed:  i32,
	failed:  i32,
	pending: i32
}

fn badhron_new_check_result() -> BadhronCheckResult {
	BadhronCheckResult {
		passed:  0,
		failed:  0,
		pending: 0
	}
}


// ====================================================================================================================
// result handler
struct BadhronResultHandler {
	passed:     fn() -> (),
	failed:     fn() -> (),
	pending :   fn() -> (),
	split:      fn() -> (),
	reset:      fn() -> (),
	total:      fn() -> BadhronCheckResult,
	exitstatus: fn() -> i32
}

fn badhron_new_result_handler() -> BadhronResultHandler {
	// FIXME
	let mut total_result = badhron_new_check_result();
	let mut split_result = badhron_new_check_result();
	let mut exitstatus = 0;

	BadhronResultHandler {
		passed:     || { split_result.passed++; },
		failed:     || { split_result.failed++; exitstatus = 1; },
		pending:    || { split_result.pending++; },

		split:      || {
			total_result.passed  += split_result.passed;
			total_result.failed  += split_result.failed;
			total_result.pending += split_result.pending;
			split_result.passed   = 0;
			split_result.failed   = 0;
			split_result.pending  = 0;
		},

		reset:      || {
			split_result.passed  = 0;
			split_result.failed  = 0;
			split_result.pending = 0;
			total_result.passed  = 0;
			total_result.failed  = 0;
			total_result.pending = 0;
		},

		total:      || {
			total_result.passed  += split_result.passed;
			total_result.failed  += split_result.failed;
			total_result.pending += split_result.pending;
			total_result
		},

		exitstatus: || { exitstatus }
	}
}
